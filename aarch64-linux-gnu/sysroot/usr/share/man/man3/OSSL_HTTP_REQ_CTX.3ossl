.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OSSL_HTTP_REQ_CTX 3ossl"
.TH OSSL_HTTP_REQ_CTX 3ossl "2021-05-02" "3.0.0-alpha16-dev" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OSSL_HTTP_REQ_CTX,
OSSL_HTTP_REQ_CTX_new,
OSSL_HTTP_REQ_CTX_free,
OSSL_HTTP_REQ_CTX_set_request_line,
OSSL_HTTP_REQ_CTX_add1_header,
OSSL_HTTP_REQ_CTX_set1_req,
OSSL_HTTP_REQ_CTX_nbio,
OSSL_HTTP_REQ_CTX_sendreq_d2i,
OSSL_HTTP_REQ_CTX_get0_mem_bio,
OSSL_HTTP_REQ_CTX_set_max_response_length
\&\- HTTP client low\-level functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/http.h>
\&
\& typedef struct ossl_http_req_ctx_st OSSL_HTTP_REQ_CTX;
\&
\& OSSL_HTTP_REQ_CTX *OSSL_HTTP_REQ_CTX_new(BIO *wbio, BIO *rbio,
\&                                          int maxline, unsigned long max_resp_len,
\&                                          int timeout,
\&                                          const char *expected_content_type,
\&                                          int expect_asn1);
\& void OSSL_HTTP_REQ_CTX_free(OSSL_HTTP_REQ_CTX *rctx);
\&
\& int OSSL_HTTP_REQ_CTX_set_request_line(OSSL_HTTP_REQ_CTX *rctx, int method_POST,
\&                                        const char *server, const char *port,
\&                                        const char *path);
\& int OSSL_HTTP_REQ_CTX_add1_header(OSSL_HTTP_REQ_CTX *rctx,
\&                                   const char *name, const char *value);
\&
\& int OSSL_HTTP_REQ_CTX_set1_req(OSSL_HTTP_REQ_CTX *rctx, const char *content_type,
\&                                const ASN1_ITEM *it, ASN1_VALUE *req);
\& int OSSL_HTTP_REQ_CTX_nbio(OSSL_HTTP_REQ_CTX *rctx);
\& ASN1_VALUE *OSSL_HTTP_REQ_CTX_sendreq_d2i(OSSL_HTTP_REQ_CTX *rctx,
\&                                           const ASN1_ITEM *it);
\&
\& BIO *OSSL_HTTP_REQ_CTX_get0_mem_bio(const OSSL_HTTP_REQ_CTX *rctx);
\& void OSSL_HTTP_REQ_CTX_set_max_response_length(OSSL_HTTP_REQ_CTX *rctx,
\&                                                unsigned long len);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\s-1OSSL_HTTP_REQ_CTX\s0\fR is a context structure for an \s-1HTTP\s0 request, used to
collect all the necessary data to perform that request.
.PP
This file documents low-level \s-1HTTP\s0 functions rarely used directly.  High-level
\&\s-1HTTP\s0 client functions like \fBOSSL_HTTP_get\fR\|(3) and \fBOSSL_HTTP_transfer\fR\|(3)
should be preferred.
.PP
\&\fBOSSL_HTTP_REQ_CTX_new()\fR allocates a new \s-1HTTP\s0 request context structure,
which gets populated with the \fB\s-1BIO\s0\fR to send the request to (\fIwbio\fR),
the \fB\s-1BIO\s0\fR to read the response from (\fIrbio\fR, which may be equal to \fIwbio\fR),
the maximum expected response header line length (\fImaxline\fR, where a value <= 0
indicates that the \fB\s-1HTTP_DEFAULT_MAX_LINE_LENGTH\s0\fR of 4KiB should be used;
this length is also used as the number of content bytes read at a time),
the maximum allowed response content length (\fImax_resp_len\fR, where 0 means
that the \fB\s-1HTTP_DEFAULT_MAX_RESP_LEN\s0\fR is used, which currently is 100 KiB),
a response timeout measure in seconds (\fItimeout\fR,
where 0 indicates no timeout, i.e., waiting indefinitely),
the expected \s-1MIME\s0 content type of the response (\fIexpected_content_type\fR,
which may be \s-1NULL\s0 for no expectation),
and a flag indicating that the response is expected to be
a \s-1DER\s0 encoded \s-1ASN.1\s0 structure (\fIexpect_asn1\fR).
The allocated context structure is also populated with an internal allocated
memory \fB\s-1BIO\s0\fR, which collects the \s-1HTTP\s0 request and additional headers as text.
The returned context should only be used for a single \s-1HTTP\s0 request/response.
.PP
\&\fBOSSL_HTTP_REQ_CTX_free()\fR frees up the \s-1HTTP\s0 request context \fIrctx\fR.
The \fIwbio\fR and \fIrbio\fR are not free'd and it is up to the application
to do so.
.PP
\&\fBOSSL_HTTP_REQ_CTX_set_request_line()\fR adds the \s-1HTTP\s0 request line to the context.
The \s-1HTTP\s0 method is determined by \fImethod_POST\fR,
which should be 1 to indicate \f(CW\*(C`POST\*(C'\fR or 0 to indicate \f(CW\*(C`GET\*(C'\fR.
\&\fIserver\fR and \fIport\fR may be set to indicate a proxy server and port
that the request should go through, otherwise they should be left \s-1NULL.\s0
\&\fIpath\fR is the \s-1HTTP\s0 request path; if left \s-1NULL,\s0 \f(CW\*(C`/\*(C'\fR is used.
.PP
\&\fBOSSL_HTTP_REQ_CTX_add1_header()\fR adds header \fIname\fR with value \fIvalue\fR to the
context \fIrctx\fR. It can be called more than once to add multiple headers.
For example, to add a \f(CW\*(C`Host\*(C'\fR header for \f(CW\*(C`example.com\*(C'\fR you would call:
.PP
.Vb 1
\& OSSL_HTTP_REQ_CTX_add1_header(ctx, "Host", "example.com");
.Ve
.PP
\&\fBOSSL_HTTP_REQ_CTX_set1_req()\fR is to be used if and only if the \fImethod_POST\fR
parameter in the \fBOSSL_HTTP_REQ_CTX_set_request_line()\fR call was 1.
It finalizes the \s-1HTTP\s0 request context by adding the \s-1DER\s0 encoding of \fIreq\fR,
using the \s-1ASN.1\s0 template \fIit\fR to do the encoding.
The \s-1HTTP\s0 header \f(CW\*(C`Content\-Length\*(C'\fR is filled out with the length of the request.
If \fIcontent_type\fR isn't \s-1NULL,\s0
the \s-1HTTP\s0 header \f(CW\*(C`Content\-Type\*(C'\fR is also added with its content as value.
All of this ends up in the internal memory \fB\s-1BIO\s0\fR.
.PP
\&\fBOSSL_HTTP_REQ_CTX_nbio()\fR attempts to send the request prepared \fIrctx\fR
and gathering the response via \s-1HTTP,\s0 using the \fIrbio\fR and \fIwbio\fR
that were given when calling \fBOSSL_HTTP_REQ_CTX_new()\fR.
When successful, the contents of the internal memory \fB\s-1BIO\s0\fR contains
the contents of the \s-1HTTP\s0 response, without the response headers.
It may need to be called again if its result is \-1, which indicates
\&\fBBIO_should_retry\fR\|(3).  In such a case it is advisable to sleep a little in
between using \fBBIO_wait\fR\|(3) on the read \s-1BIO\s0 to prevent a busy loop.
.PP
\&\fBOSSL_HTTP_REQ_CTX_sendreq_d2i()\fR calls \fBOSSL_HTTP_REQ_CTX_nbio()\fR, possibly
several times until a timeout is reached, and \s-1DER\s0 decodes the received
response using the \s-1ASN.1\s0 template \fIit\fR.
.PP
\&\fBOSSL_HTTP_REQ_CTX_get0_mem_bio()\fR returns the internal memory \fB\s-1BIO\s0\fR.
Before sending the request, this could used to modify the \s-1HTTP\s0 request text.
\&\fIUse with caution!\fR
After receiving a response via \s-1HTTP,\s0 the \s-1BIO\s0 represents
the current state of reading the response headers and contents.
.PP
\&\fBOSSL_HTTP_REQ_CTX_set_max_response_length()\fR sets the maximum allowed
response content length for \fIrctx\fR to \fIlen\fR. If not set or \fIlen\fR is 0
then the \fB\s-1HTTP_DEFAULT_MAX_RESP_LEN\s0\fR is used, which currently is 100 KiB.
If the \f(CW\*(C`Content\-Length\*(C'\fR header is present and exceeds this value or
the content is an \s-1ASN.1\s0 encoded structure with a length exceeding this value
or both length indications are present but disagree then an error occurs.
.SH "WARNINGS"
.IX Header "WARNINGS"
The server's response may be unexpected if the hostname that was used to
create the \fIwbio\fR, any \f(CW\*(C`Host\*(C'\fR header, and the host specified in the
request \s-1URL\s0 do not match.
.PP
Many of these functions must be called in a certain order.
.PP
First, the \s-1HTTP\s0 request context must be allocated:
\&\fBOSSL_HTTP_REQ_CTX_new()\fR.
.PP
Then, the \s-1HTTP\s0 request must be prepared with request data:
.IP "1." 4
Calling \fBOSSL_HTTP_REQ_CTX_set_request_line()\fR.  This must be done exactly once.
.IP "2." 4
Adding extra headers with \fBOSSL_HTTP_REQ_CTX_add1_header()\fR.
This is optional and may be done multiple times with different names.
.IP "3." 4
Add \f(CW\*(C`POST\*(C'\fR data with \fBOSSL_HTTP_REQ_CTX_set1_req()\fR.  This may only be done if
\&\fImethod_POST\fR was 1 in the \fBOSSL_HTTP_REQ_CTX_set_request_line()\fR call,
and must be done exactly once in that case.
.PP
When the request context is fully prepared, the \s-1HTTP\s0 exchange may be performed
with \fBOSSL_HTTP_REQ_CTX_nbio()\fR or \fBOSSL_HTTP_REQ_CTX_sendreq_d2i()\fR.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fBOSSL_HTTP_REQ_CTX_new()\fR returns a pointer to a \fB\s-1OSSL_HTTP_REQ_CTX\s0\fR, or \s-1NULL\s0
on error.
.PP
\&\fBOSSL_HTTP_REQ_CTX_free()\fR and \fBOSSL_HTTP_REQ_CTX_set_max_response_length()\fR
do not return values.
.PP
\&\fBOSSL_HTTP_REQ_CTX_set_request_line()\fR, \fBOSSL_HTTP_REQ_CTX_add1_header()\fR,
\&\fBOSSL_HTTP_REQ_CTX_set1_req()\fR and OSSL_HTTP_REQ_CTX_nbio
return 1 for success and 0 for failure.
.PP
\&\fBOSSL_HTTP_REQ_CTX_sendreq_d2i()\fR returns a pointer to an \fB\s-1ASN1_VALUE\s0\fR for
success and \s-1NULL\s0 for failure.
.PP
\&\fBOSSL_HTTP_REQ_CTX_get0_mem_bio()\fR returns the internal memory \fB\s-1BIO\s0\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBBIO_should_retry\fR\|(3),
\&\fBBIO_wait\fR\|(3),
\&\fBOSSL_HTTP_get\fR\|(3),
\&\fBOSSL_HTTP_transfer\fR\|(3)
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2015\-2021 The OpenSSL Project Authors. All Rights Reserved.
.PP
Licensed under the Apache License 2.0 (the \*(L"License\*(R").  You may not use
this file except in compliance with the License.  You can obtain a copy
in the file \s-1LICENSE\s0 in the source distribution or at
<https://www.openssl.org/source/license.html>.
